# Complete Guide: Connecting AI Agents to Databases with MCP

## Introduction

The Model Context Protocol (MCP) is revolutionizing how AI agents interact with external data sources. In this comprehensive guide, we'll explore how to connect an AI agent to a database using MCP, with practical examples using PostgreSQL.

## What is MCP?

Model Context Protocol is an open standard that enables AI assistants to securely connect to data sources and tools. Think of it as a universal adapter that allows AI agents to interact with databases, APIs, and other systems in a standardized way.

### Key Benefits

- **Standardized Communication**: One protocol for multiple data sources
- **Security**: Controlled access with proper authentication
- **Context Awareness**: Agents understand database structure and relationships
- **Flexibility**: Works with various databases (PostgreSQL, MySQL, SQLite, etc.)

## Architecture Overview

```
┌─────────────────┐
│   AI Agent      │
│  (Claude/GPT)   │
└────────┬────────┘
         │
         │ Natural Language Query
         ▼
┌─────────────────┐
│   MCP Server    │
│                 │
│  - Query Parser │
│  - Schema Cache │
│  - SQL Generator│
└────────┬────────┘
         │
         │ SQL Commands
         ▼
┌─────────────────┐
│   Database      │
│  (PostgreSQL)   │
└─────────────────┘
```

## Setting Up Your Environment

### Prerequisites

```bash
# Install Node.js (v18 or higher)
node --version

# Install MCP CLI
npm install -g @modelcontextprotocol/cli

# Install database MCP server
npm install -g @modelcontextprotocol/server-postgres
```

### Example Database: Public PostgreSQL Instance

For this tutorial, we'll use a sample e-commerce database. You can use services like ElephantSQL or Supabase for free PostgreSQL hosting.

**Sample Database Schema:**

```sql
-- Products Table
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2),
    category VARCHAR(100),
    stock_quantity INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Customers Table
CREATE TABLE customers (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Orders Table
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(id),
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10, 2),
    status VARCHAR(50)
);

-- Order Items Table
CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id),
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER,
    price DECIMAL(10, 2)
);
```

## Configuring MCP for Database Access

### Step 1: Create MCP Configuration File

Create a file named `mcp-config.json`:

```json
{
  "mcpServers": {
    "postgres-ecommerce": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-postgres",
        "postgresql://username:password@host:5432/ecommerce_db"
      ],
      "env": {
        "POSTGRES_MAX_CONNECTIONS": "10"
      }
    }
  }
}
```

### Step 2: Store Database Schema Information

Create a `schema-context.json` file to help the agent understand your database:

```json
{
  "database": "ecommerce_db",
  "version": "1.0",
  "tables": {
    "products": {
      "description": "Product catalog with inventory information",
      "primaryKey": "id",
      "columns": {
        "id": "Unique product identifier",
        "name": "Product name",
        "description": "Detailed product description",
        "price": "Product price in USD",
        "category": "Product category (Electronics, Clothing, Books, etc.)",
        "stock_quantity": "Available inventory count"
      },
      "commonQueries": [
        "Find products by category",
        "Check product availability",
        "Get products below certain price"
      ]
    },
    "customers": {
      "description": "Customer information and contact details",
      "primaryKey": "id",
      "columns": {
        "id": "Unique customer identifier",
        "email": "Customer email address (unique)",
        "first_name": "Customer first name",
        "last_name": "Customer last name"
      }
    },
    "orders": {
      "description": "Customer orders and their status",
      "primaryKey": "id",
      "relationships": {
        "customer_id": "Links to customers.id"
      },
      "columns": {
        "status": "Values: pending, processing, shipped, delivered, cancelled"
      }
    },
    "order_items": {
      "description": "Individual items within each order",
      "primaryKey": "id",
      "relationships": {
        "order_id": "Links to orders.id",
        "product_id": "Links to products.id"
      }
    }
  },
  "relationships": [
    {
      "type": "one-to-many",
      "from": "customers",
      "to": "orders",
      "description": "Each customer can have multiple orders"
    },
    {
      "type": "one-to-many",
      "from": "orders",
      "to": "order_items",
      "description": "Each order contains multiple items"
    },
    {
      "type": "many-to-one",
      "from": "order_items",
      "to": "products",
      "description": "Each order item references a product"
    }
  ],
  "businessRules": {
    "inventory": "Stock quantity must be checked before order placement",
    "pricing": "Prices stored in USD with 2 decimal precision",
    "orderStatus": "Status workflow: pending → processing → shipped → delivered"
  }
}
```

## How the AI Agent Uses MCP

### Request Flow Diagram

```
User Query: "Show me electronics under $500"
    │
    ▼
┌───────────────────────────────────┐
│  1. Agent Receives Query          │
└───────────┬───────────────────────┘
            │
            ▼
┌───────────────────────────────────┐
│  2. Agent Analyzes Intent         │
│     - Identifies: product search  │
│     - Filters: category, price    │
└───────────┬───────────────────────┘
            │
            ▼
┌───────────────────────────────────┐
│  3. MCP Translates to SQL         │
│     SELECT * FROM products        │
│     WHERE category = 'Electronics'│
│     AND price < 500               │
└───────────┬───────────────────────┘
            │
            ▼
┌───────────────────────────────────┐
│  4. Database Executes Query       │
└───────────┬───────────────────────┘
            │
            ▼
┌───────────────────────────────────┐
│  5. MCP Returns Structured Data   │
└───────────┬───────────────────────┘
            │
            ▼
┌───────────────────────────────────┐
│  6. Agent Formats Response        │
│     "I found 12 electronics..."   │
└───────────────────────────────────┘
```

### Example Interactions

**Interaction 1: Simple Query**

```
User: "How many products do we have in stock?"

Agent Process:
1. Identifies query type: COUNT aggregation
2. Uses schema context to find 'products' table
3. Generates SQL: SELECT COUNT(*) FROM products WHERE stock_quantity > 0
4. Returns: "We have 247 products currently in stock."
```

**Interaction 2: Complex Join Query**

```
User: "Who are our top 5 customers by total spending?"

Agent Process:
1. Identifies: aggregation + join + ordering
2. References schema relationships
3. Generates SQL:
   SELECT c.first_name, c.last_name, SUM(o.total_amount) as total_spent
   FROM customers c
   JOIN orders o ON c.id = o.customer_id
   GROUP BY c.id, c.first_name, c.last_name
   ORDER BY total_spent DESC
   LIMIT 5
4. Returns formatted list of top customers
```

## Best Practices for Schema Documentation

### 1. Create a Models Directory Structure

```
project/
├── mcp-config.json
├── schema/
│   ├── schema-context.json
│   ├── models/
│   │   ├── product.model.json
│   │   ├── customer.model.json
│   │   ├── order.model.json
│   │   └── order-item.model.json
│   └── relationships.json
└── prompts/
    ├── system-prompt.txt
    └── query-examples.txt
```

### 2. Individual Model Files

**product.model.json:**

```json
{
  "model": "Product",
  "table": "products",
  "description": "Represents items available for purchase in the catalog",
  "fields": {
    "id": {
      "type": "integer",
      "description": "Auto-incrementing primary key",
      "constraints": ["PRIMARY KEY", "NOT NULL"]
    },
    "name": {
      "type": "string",
      "maxLength": 255,
      "description": "Display name of the product",
      "searchable": true
    },
    "price": {
      "type": "decimal",
      "precision": [10, 2],
      "description": "Price in USD",
      "constraints": ["CHECK (price >= 0)"]
    },
    "category": {
      "type": "string",
      "description": "Product classification",
      "enum": ["Electronics", "Clothing", "Books", "Home", "Sports"],
      "indexed": true
    }
  },
  "indexes": [
    {
      "name": "idx_category",
      "columns": ["category"]
    },
    {
      "name": "idx_price",
      "columns": ["price"]
    }
  ],
  "commonOperations": {
    "findByCategory": "SELECT * FROM products WHERE category = ?",
    "checkAvailability": "SELECT * FROM products WHERE id = ? AND stock_quantity > 0",
    "searchByName": "SELECT * FROM products WHERE name ILIKE ?"
  }
}
```

### 3. System Prompt for the Agent

**system-prompt.txt:**

```
You are a database assistant with access to an e-commerce database through MCP.

DATABASE CONTEXT:
- Database: PostgreSQL e-commerce system
- Tables: products, customers, orders, order_items
- Always check schema-context.json before querying

QUERY GUIDELINES:
1. Use parameterized queries to prevent SQL injection
2. Respect the relationships defined in the schema
3. Apply business rules (check inventory before orders)
4. Use appropriate indexes for performance
5. Limit large result sets (default LIMIT 100)

RESPONSE FORMAT:
- For data queries: Return formatted tables or lists
- For counts: Return the number with context
- For errors: Explain what went wrong in plain language
- Always confirm before executing UPDATE or DELETE operations

AVAILABLE OPERATIONS:
- SELECT: Read data from tables
- INSERT: Add new records (after validation)
- UPDATE: Modify existing records (with confirmation)
- DELETE: Remove records (with confirmation)
- AGGREGATE: COUNT, SUM, AVG, MIN, MAX operations
```

## Security Considerations

### 1. Connection Security

```json
{
  "connection": {
    "ssl": true,
    "sslmode": "require",
    "connection_timeout": 10,
    "statement_timeout": 30000
  }
}
```

### 2. Access Control

```json
{
  "permissions": {
    "allowedOperations": ["SELECT", "INSERT"],
    "restrictedTables": ["user_credentials", "payment_info"],
    "readOnlyTables": ["audit_logs"],
    "requireConfirmation": ["UPDATE", "DELETE"]
  }
}
```

### 3. Query Validation

The MCP server should validate queries before execution:

- Check for destructive operations
- Validate table and column names
- Prevent SQL injection
- Limit result set sizes
- Monitor query performance

## Monitoring and Logging

### Query Log Format

```json
{
  "timestamp": "2025-10-07T10:30:00Z",
  "query": "SELECT * FROM products WHERE category = 'Electronics'",
  "executionTime": 45,
  "rowsReturned": 23,
  "user": "agent-session-123",
  "success": true
}
```

## Troubleshooting Common Issues

### Issue 1: Connection Timeout

**Solution:** Check network connectivity and increase timeout values

```json
{
  "connection_timeout": 30,
  "statement_timeout": 60000
}
```

### Issue 2: Schema Not Found

**Solution:** Ensure schema-context.json is loaded at startup

```javascript
// Verify schema loading
const schema = require('./schema/schema-context.json');
console.log('Loaded tables:', Object.keys(schema.tables));
```

### Issue 3: Slow Queries

**Solution:** Add appropriate indexes and use EXPLAIN

```sql
EXPLAIN ANALYZE
SELECT * FROM products WHERE category = 'Electronics';
```

## Advanced Features

### 1. Query Optimization Hints

Store common query patterns with optimizations:

```json
{
  "queryPatterns": {
    "productSearch": {
      "pattern": "search products by category and price range",
      "optimizedSQL": "SELECT * FROM products WHERE category = ? AND price BETWEEN ? AND ? ORDER BY price",
      "useIndex": "idx_category_price"
    }
  }
}
```

### 2. Caching Strategy

```json
{
  "caching": {
    "enabled": true,
    "ttl": 300,
    "cacheableQueries": [
      "SELECT * FROM products WHERE category = ?",
      "SELECT COUNT(*) FROM products"
    ]
  }
}
```

### 3. Real-time Updates

Implement webhooks for database changes:

```javascript
// Notify agent of inventory changes
db.on('update', (table, record) => {
  if (table === 'products' && record.stock_quantity < 10) {
    mcp.notify('low_inventory', record);
  }
});
```

## Conclusion

MCP provides a powerful, standardized way to connect AI agents to databases. By following this guide, you can:

- Set up secure database connections
- Provide rich context through schema documentation
- Enable natural language database queries
- Implement proper security and monitoring
- Scale your AI-powered applications

## Next Steps

1. **Experiment**: Try connecting to your own database
2. **Extend**: Add more tables and relationships
3. **Optimize**: Monitor query performance and add indexes
4. **Secure**: Implement proper authentication and authorization
5. **Scale**: Use connection pooling and caching for production

## Resources

- MCP Documentation: https://modelcontextprotocol.io
- PostgreSQL MCP Server: https://github.com/modelcontextprotocol/servers
- Sample Database Scripts: Available in the tutorial repository

---

*Ready to supercharge your AI agent with database access? Start implementing MCP today!*